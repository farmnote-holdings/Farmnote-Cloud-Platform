# **Farmnote Cloud Figmaデザインガイドライン**

## **1\. はじめに**

### **1.1. このガイドラインの目的**

このドキュメントは、Farmnote Cloud PlatformのUI/UX設計に関わるすべてのメンバー（デザイナー、エンジニア、プロダクトマネージャー等）のための公式なFigma利用ガイドラインです。

本ガイドラインの目的は、製品戦略とデザインシステムの原則に基づき、Figma上でのデザインプロセスを標準化することです。これにより、「インテリジェント」「ストレスフリー」「統合された」ユーザー体験を、チーム一丸となって効率的かつ一貫性をもって実現します。

### **1.2. ガイドラインが目指す状態**

* **予測可能性:** 誰がファイルを開いても、目的のデザインアセットをすぐに見つけられる。  
* **一貫性:** すべてのデザインがデザインシステムのルールに準拠し、プラットフォーム全体で統一された体験を提供する。  
* **効率性:** ルール化とコンポーネント化により、無駄な作業をなくし、設計と開発のスピードを向上させる。  
* **協調性:** デザイナーとエンジニアが共通の言語と構造でスムーズに連携できる。

## **2\. ファイル・ページ構成**

Farmnote Cloud Platformは複数の専門アプリケーションで構成されるため、Figmaファイル内のページをアプリケーション単位で明確に分離し、ファイル全体の可読性とパフォーマンスを維持します。

### **2.1. 推奨ページ構成**

| アイコン | ページ名 | 説明 |
| :---- | :---- | :---- |
| ✅ | **Cover** | ファイルの表紙。プロジェクト概要、ステータス、更新履歴を記載します。 |
| 🧩 | **Design System** | カラー、タイポグラフィ、アイコン等、プラットフォーム共通のコンポーネントを定義します。 |
| \--- | \--- | \--- |
| 🐄 | **Herd Management** | Herd Managementアプリの画面デザイン。画面数が多い場合は機能で分割も可。 |
| 📊 | **Compass** | Compassアプリの画面デザイン。 |
| 🧬 | **Gene** | Geneアプリの画面デザイン。 |
| 🤖 | **Assistant** | Assistantアプリの画面デザイン。 |
| 🛒 | **Inventory** | Inventoryアプリの画面デザイン。 |
| 👤 | **Account Portal** | Account Portalアプリの画面デザイン。 |
| \--- | \--- | \--- |
| 🌊 | **Prototypes** | アプリを横断するプロトタイプや、複雑なユーザーフロー図を配置します。 |
| ✍️ | **Sandbox \- \[担当者名\]** | 各担当者が自由に試行錯誤するための、個人作業用のページです。 |
| 📌 | **Archive** | 古くなったデザインや不採用案を保管するページです。 |

## **3\. 命名規則**

命名にはスラッシュ / を用いて階層構造を表現し、Figmaのアセットパネルでの整理と検索を容易にします。

### **3.1. 画面フレーム (トップレベルフレーム)**

PCとタブレットの表示は基本的に共通とし、管理コストを削減するため、主要なデザインターゲットを**デスクトップ**と**スマートフォン**の2つに絞ります。

**フォーマット:** \[デバイスアイコン\] \[アプリ名\] / \[ページ名\] / \[状態・バリエーション\]

* **デバイスアイコン:**  
  * 🖥️ : デスクトップ (タブレット表示も兼ねる)  
  * 📱 : スマートフォン  
* **アプリ名:** 製品戦略で定義された正式名称を使用します。（例: Herd Management, Compass）  
* **ページ名:** 画面の内容が具体的にわかる名前を付けます。（例: Cow List, KPI Dashboard）  
* **状態・バリエーション (接頭辞 \_ を使用):** 画面の特定の状態を示します。  
  * \_Default: 基本状態  
  * \_Empty: データが空の状態  
  * \_Loading: 読み込み中  
  * \_SideOverviewOpen: サイドオーバービュー表示時  
  * **例外的なタブレット表示:** もしタブレットで特有のレイアウトが必要な場合は、\_Tablet のようにバリエーションとして表現します。

**命名例:**

* 🖥️ Herd Management / Cow List / \_Default  
* 🖥️ Compass / KPI Dashboard / \_ProfitImpact  
* 📱 Assistant / Chat / \_HandsFreeInput  
* 🖥️ Herd Management / Farm Board / \_Tablet (例外的なケース)

### **3.2. コンポーネントの整理とバリアント**

コンポーネントの管理は、**フレームによる分類**と**バリアントによる状態管理**を組み合わせて行います。これにより、ライブラリの整理と、効率的なデザイン作業を両立します。

#### 整理方法 (フレーム構造):

1. Design Systemページ内に、コンポーネントを以下の分類に基づいたフレームに分けて整理します。  
   * **Atoms:** UIを構成する最小単位。（例: Button, Input, Label）  
   * **Molecules:** 複数のAtomsで構成される小さな機能単位。（例: InputField, SearchForm）  
   * **Organisms:** 複数のMoleculesやAtomsで構成される、より自立したUIパーツ。（例: Header, Card）  
   * **Platform Specifics:** 特定のアプリに強く依存し、再利用性が低い複雑なコンポーネント。（例: SideOverviewPanel）  
2. 各フレーム内に、対応するマスターコンポーネント（コンポーネントセット）を配置します。

#### バリアントによる状態管理:  
複数の状態や種類を持つコンポーネントは、個別のコンポーネントを複数作成するのではなく、Figmaのコンポーネントプロパティ（バリアント）機能を活用して、単一のコンポーネントセットにまとめます。

* **コンポーネント名:** コンポーネントセット自体の名前は、ButtonやCardのように、その役割を示すシンプルなものにします。  
* **プロパティ定義:** Type（種類）、Size（サイズ）、State（状態）といった明確なプロパティを定義します。プロパティ名と値は、全コンポーネントで統一します。  
* **Inputコンポーネントの設計:**  
  * **Input (Atom):** \<input\>や\<textarea\>タグに相当する、純粋な入力要素。  
    * プロパティ: Type: Text/Password/Textarea, Size: Lg/Md/Sm, State: Default/Hover/Focus/Filled/Error/Disabled  
  * **InputField (Molecule):** ラベル、説明文、エラー文を含む、フォームの1項目全体。  
    * プロパティ: WithLabel: True/False, WithDescription: True/False, WithError: True/False, Required: True/False  
* **アイコン関連プロパティ:** アイコンを含むコンポーネント（例: Button）には、以下のプロパティを追加します。  
  * ShowIcon (ブーリアン): アイコンの表示/非表示を切り替えます。  
  * IconPosition (バリアント): Left, Right のいずれかを指定します。  
  * Icon (インスタンススワップ): 表示するアイコンコンポーネント（例: Icon/Lucide/Home）を差し替えます。


### **3.3. 命名の原則 (Naming Principles)**

* **文脈に応じた命名 (Context-Based Naming):** コンポーネントを汎用的に作るか、専用に作るかの判断は、再利用性の鍵となります。以下の基準で判断します。
	- **専用コンポーネントとして作成するケース:** `NavItem`や`PopupItem`, `ActivityBtn`のように、使われる文脈（場所）と、それに最適化された具体的な見た目（サイズ、余白、スタイル）が密接に結びついている場合。これらは、その文脈に特化した名前で作成します。
	- **汎用コンポーネントとして作成するケース:** `Button`や`Card`のように、アプリケーションの様々な場所で、同じ見た目・同じルールで再利用されることが明確な場合。これらは、その構造や役割を示す汎用的な名前で作成します。
* **パスカルケースの使用 (Use of PascalCase)**:  
  コンポーネント名、プロパティ名、プロパティの値は、スペースを含まず、単語の先頭を大文字でつなげるパスカルケース（例: NavItem, SideOverviewPanel, ShowIcon, IconPosition）で記述します。これはReactなどのフレームワークにおける標準的な命名規則であり、開発との連携をスムーズにします。  
* **コードとの連携 (Alignment with Code)**:  
  Figma上の名称は、可能な限りコードベースやデザイントークンで使われている用語と一致させます。  
* **明確さを優先 (Clarity over Brevity)**:  
  チームで共通認識が取れないような、難解な省略形は避けます。基本的には省略せずに明確な名前を使用することを推奨しますが、一般的に広く使われている以下の略称については、チームの共通言語として使用を許可します。

| 正式名称 | 略称 | 備考 |
| :---- | :---- | :---- |
| Button | Btn |  |
| Image | Img |  |
| Navigation | Nav |  |
| Message | Msg |  |
| Dialog | Dlg |  |
| Table | Tbl |  |
| Thumbnail | Thumb |  |
| Background | BG |  |
| Number | Num |  |
| Checkbox | Chk |  |

* **役割に応じたインスタンス名の付与 (Assigning Role-Based Instance Names)**:  
  同じコンポーネントやフレームでも、文脈によって役割が異なる場合があります。その場合、レイヤーパネル上での可読性を高めるため、インスタンス名に役割を示す接尾辞を追加します。これらはFigma上の管理名でありコードには影響しないため、半角スペースの使用を許可します。  
  * **フォーマット:** \[元の名前\] \- \[役割\]  
  * **例:** NavList \- Menu, NavList \- CowList  
* **内部コンポーネントの区別 (Distinguishing Internal Components)**:  
  ライブラリとして公開せず、内部でのみ使用するコンポーネント（例：他のコンポーネントの基礎となる部品）には、名前の先頭にアンダースコア \_ を付けます。Figmaの仕様上、\_ や . で始まるコンポーネントはライブラリから除外されるため、利用者向けのライブラリを整理された状態に保つことができます。
* **アイコンの命名規則**:
	* アイコンは数が多く、パフォーマンスへの影響を考慮するため、バリアントは使用せず、個別のコンポーネントとして管理します。
		* **フォーマット:** Icon/\[ライブラリ\]/\[アイコン名\]  
		* **ライブラリ:** Lucide を基本とします。カスタムアイコンの場合は Custom とします。  
		* **アイコン名:** Lucide のアイコン名（例: Home, User）をそのまま使用します。  
		* **整理方法:** Design Systemページ内に、Iconsフレームを作成し、その中にLucideなどのサブフレームを作って、マスターコンポーネントを視覚的に整理します。

## **4\. フレーム構造ルール**

メンテナンス性と拡張性を高めるため、フレームの構造に以下のルールを設けます。これはデザイナーとエンジニア間の共通言語としても機能します。

### **4.1. Auto Layoutの基本原則**

* **柔軟なコンポーネント設計**:  
  マージン、パディング、要素間のスペース管理には、Auto Layoutを全面的に採用します。これにより、デザインシステムで定義されたスペーシングスケール（8pxグリッド）を遵守し、要素の追加・削除に柔軟に対応できます。例えば、ボタンのラベルが長くなっても幅が自動で調整されるように設定することで、「テキスト長S/M/L」のような不要なバリアントを作成する必要がなくなります。  
* **意図が伝わるレイヤー名**:  
  Auto Layoutを適用したフレームには、そのレイアウト意図がひと目で分かる名前を付けます。これらはFigma上の管理名のため、半角スペースの使用を許可します。（例：📏 Padding Wrapper, text \+ icon）

### **4.2. バリアントのレイヤー構造統一**

* **上書き保持のための構造統一**:  
  同一コンポーネントセット内の全バリアントで、レイヤー構造と名前付けを完全に一致させます。これは、バリアントの状態を切り替えた際に、テキストやインスタンスの上書き内容を保持するために不可欠です。例えば、あるバリアントのテキストレイヤー名が Label であれば、他の全バリアントでも同じレイヤー名を Label に統一してください。  
* **一括編集の実現**:  
  レイヤー構造を統一することで、複数のバリアントを選択して一括で編集したり、レイヤーの表示/非表示を切り替えるブーリアンプロパティを一貫して適用したりすることが可能になり、管理が大幅に容易になります。

### **4.3. Container パターンによるコンテンツ幅の制御**

ヘッダーやサイドバーは画面幅いっぱいに広げつつ、**メインコンテンツ領域の可読性を担保するため**にContainerフレームを配置します。

* **役割:** **メインコンテンツ領域に最大幅（例: 1280px）を設定し、コンテンツが横に広がりすぎるのを防ぎます。** これにより、横長のディスプレイでもユーザーの視線移動が最適化され、快適な閲覧体験を提供します。  
* **配置場所:** ページ全体ではなく、**メインコンテンツをラップする形**で配置します。

### **4.4. Wrapper / Content パターンによるコンポーネント設計**

ヘッダーやカードなど、**少し複雑なコンポーネント**を設計する際は、**外側（Wrapper）と内側（Content）でフレームを分離する**ことで、柔軟性とメンテナンス性を高めます。

* **Wrapper (ラッパー):** コンポーネントの一番外側のフレームがこの役割を担います。実際のフレーム名はコンポーネント名（例: Header, Card）とし、背景色、枠線、角丸、影などの**装飾**を設定します。  
* **Content (コンテンツ):** Wrapperの直下に配置し、フレーム名を **Content** とします。このフレームは、コンテンツそのものと、内側の余白（**Padding**）を管理します。ヘッダーのように、画面幅いっぱいの背景の中でコンテンツの幅を制御したい場合は、このContentフレームに最大幅を設定します。  
* **メリット:** 「装飾」と「中身・余白」の役割を分離でき、堅牢で再利用性の高いコンポーネント設計が可能になります。

#### **このパターンの使い分け**

このパターンは、**コンポーネントの複雑さに応じて柔軟に使い分けます。**

* **推奨するケース（複雑なコンポーネント）:**  
  * ヘッダー、サイドバー、カード、モーダルなど、内部に複数の要素を持ち、レイアウトの分離が有効な場合。  
* **不要なケース（シンプルなコンポーネント）:**  
  * ボタンやタグなど、単一のフレームで背景と余白を十分に管理できる場合。不必要に階層を深くすると、かえって管理が煩雑になります。

### **4.5. ContainerとContentの役割分担**

ContainerとContentは似ていますが、明確な役割の違いがあります。これらを区別することで、レイアウトの意図がより明確になります。

* **Containerの役割: ページの「メインコンテンツ幅」を制御する**  
  * これは、**ページ全体のレイアウト**に関わる、大きな枠組みです。  
  * 主な目的は、PCなどの横長の画面で、本文やリストなどの主要なコンテンツが横に広がりすぎて見づらくなるのを防ぐことです。  
* **Contentの役割: 「コンポーネント内部」の余白と要素を管理する**  
  * これは、HeaderやNavBar、Cardといった、**個々のコンポーネントの内部構造**に関わる、小さな枠組みです。  
  * 主な目的は、そのコンポーネントの中でのPadding（内側の余白）や、要素（ロゴ、テキスト、アイコンなど）の配置を管理することです。

\*\*Containerは「ページの器」、Contentは「部品の中身」\*\*と役割を明確に分けることで、デザイナーもエンジニアも、そのフレームが何のためのものかを直感的に理解できるようになります。

### **4.6. 推奨フレーム構造（全体像）**

アプリケーションの基本的なレイアウトとして、以下の「App Shell」モデルを推奨します。

🖥️ Herd Management / Cow List / \_Default (画面フレーム)  
│  
└─ 📄 App (Auto Layout: 横)  
   │ // アプリケーション全体のラッパー  
   │  
   ├─ 🧩 NavBar (Component)  
   │  │ // 左側固定のメインナビゲーション  
   │  │  
   │  └─ 📄 Content (Auto Layout: 縦)  
   │     │  
   │     ├─ 🧩 AppSwitcher (Component)  
   │     └─ 📄 NavGroup (Auto Layout: 縦)  
   │        └─ ... (NavList)  
   │  
   └─ 📄 Main (Auto Layout: 縦)  
      │ // メインコンテンツ領域  
      │  
      ├─ 🧩 TopBar (Component)  
      │  │ // ページタイトルやアクションを配置  
      │  
      └─ 📄 MainContentArea (Auto Layout: 横)  
         │ // メインコンテンツと右サイドバーのラッパー  
         │  
         ├─ 📄 Container (Auto Layout: 縦)  
         │  │ // メインコンテンツの最大幅を制御  
         │  │  
         │  └─ ... (テーブルやカードなどの主要コンテンツ)  
         │  
         └─ 🧩 SideBar (Component)  
            │ // 右からスライドインする補助的なパネル  
            │ // (例: フィルタ、並び替え、詳細情報)  
            │ // デフォルトは非表示

### **4.7. 標準レイアウトプラクティス**

一貫性のあるレイアウトを効率的に構築するため、Auto Layoutやスペーシングに関する標準プラクティスを定めます。

プラットフォーム全体で視覚的なリズムと秩序を生むための**スペーシングシステム（8pxグリッド）や、主要コンポーネント（Card, Form, Modalなど）の標準レイアウトに関する具体的な数値やルールは、別途管理されている公式のデザインシステムドキュメント**に定義されています。デザインを構築する際は、必ずそちらを参照してください。

* **レスポンシブ挙動の指針**:  
  Auto LayoutのResizing設定は、以下の指針で使い分けます。  
  * **Fill Container:** 親フレームのサイズ変更に追従させたい場合に原則として使用します。  
  * **Hug Contents:** コンテンツ自身のサイズ（テキスト長など）に合わせてフレームサイズを可変させたい場合（例: ボタン、タグ）に使用します。  
  * **Fixed:** サイズを固定したい場合（例: アバター、特定のサイズのアイコン）に使用します。  
* **コンポーネントへの説明付記**:  
  複雑なコンポーネントには、FigmaのプロパティパネルのDescription欄を使って、構造や用途に関する簡潔な説明を付記することを推奨します。これにより、設計意図が伝わりやすくなります。

## **5\. デザインシステムとの連携**

Figma上のデザインは、必ず公式の「Farmnote Cloud Platform デザインシステム」と連携している必要があります。

### **5.1. コンポーネントはインスタンスで利用する**

デザインシステムで定義されたコンポーネントは、必ず**インスタンス（Instance）として使用**します。コンポーネントをデタッチしてローカルで編集することは、一貫性を破壊し、メンテナンス性を著しく低下させるため**原則として禁止**します。

### **5.2. スタイルを適用する**

カラー、タイポグラフィ、エフェクト（影）、グリッドは、必ずデザインシステムで定義された**スタイルを適用**します。ローカルで直接カラーコードやフォントサイズを指定することは避けてください。これにより、デザインシステム側の変更が全てのデザインに即座に反映されます。

## **6\. 開発連携 (Collaboration with Development)**

### **6.1. FigmaからReactへの連携**

本ガイドラインのコンポーネント管理方法は、Reactなどのコンポーネントベースのフレームワークとの連携を円滑にするために設計されています。Figma上のコンポーネントプロパティは、そのまま実装の仕様書として機能します。

#### **命名規則と実装のマッピング**

Figmaのコンポーネントは、以下のようにReactコンポーネントに変換されることを意図しています。

1. **コンポーネントの分類 → ファイルパス**  
   * Figma: Atomsフレーム内に配置されたButtonコンポーネント  
   * React: src/components/atoms/Button.tsx のように、分類フレーム名がフォルダパスに対応します。  
2. **コンポーネントプロパティ → Props (プロパティ)**  
   * Figma: Type=Primary, Size=Md, State=Default, ShowIcon=True のプロパティを持つButtonコンポーネント  
   * React: \<Button type="primary" size="md" state="default" showIcon={true}\> のように、各プロパティがPropsとして実装されます。  
3. **InputFieldとInputの関係**  
   * InputFieldは、Inputを子要素として受け取るラッパーコンポーネントとして実装します。  
   * \<InputField label="名前" error="必須です"\>\<Input type="text" /\>\</InputField\>  
4. **アイコンの場合**  
   * Figma: Icon/Lucide/Home  
   * React: \<Icon library="lucide" name="home" /\> のように、専用のIconコンポーネントでライブラリと名前をPropsとして渡します。

#### **具体例**

| Figmaでのコンポーネント | Reactでの実装（JSX） |
| :---- | :---- |
| Button (Type=Primary, Size=Md, ShowIcon=True, Icon=Icon/Lucide/Save) | \<Button type="primary" size="md" icon={\<Icon name="save" /\>}\>保存\</Button\> |
| InputFieldとInput | \<InputField label="名前"\>\<Input type="text" /\>\</InputField\> |

#### **このルールのメリット**

* **明確なProps設計:** デザイナーがバリアントを作成する時点で、開発者は必要なPropsを直感的に理解できます。  
* **コンポーネントの再利用性向上:** PrimaryButton のような個別のコンポーネントを乱立させるのではなく、一つの Button コンポーネントをPropsで制御する、効率的で再利用性の高い設計を促進します。  
* **共通言語の確立:** デザイナーと開発者が「ButtonコンポーネントのPrimary-Disabledの状態」といったように、完全に一貫した言葉でコミュニケーションを取れるようになります。

## **7\. 付録 (Appendix)**

### **7.1. プロパティ チートシート**

コンポーネントのプロパティで頻繁に使用する命名の定義一覧です。

| プロパティの種類 | プロパティ名 | 説明 |
| :---- | :---- | :---- |
| **種類 (Type)** | Primary | 最も重要なアクション。画面内で使用数を限定する。 |
|  | Secondary | 2番目に重要なアクション。 |
|  | Tertiary | テキストのみなど、最も優先度の低いアクション。 |
|  | Danger | 破壊的なアクション（削除など）。 |
| **サイズ (Size)** | Lg (Large) | 大きいサイズのコンポーネント。 |
|  | Md (Medium) | 標準サイズのコンポーネント。 |
|  | Sm (Small) | 小さいサイズのコンポーネント。 |
| **状態 (State)** | Default | 静的な通常の状態。 |
|  | Hover | マウスカーソルが乗っている状態。 |
|  | Active | クリック中、または選択中の状態。 |
|  | Focus | キーボード操作などでフォーカスが当たっている状態。 |
|  | Loading | 処理中で、操作を待機している状態。 |
|  | Disabled | 操作不可能な状態。 |
| **アイコン (Icon)** | ShowIcon | (Boolean) アイコンの表示/非表示を切り替える。 |
|  | IconPosition | (Variant) Left / Right でアイコンの位置を指定。 |
|  | Icon | (Instance Swap) 表示するアイコンコンポーネントを差し替える。 |

### **7.2. コンポーネントの探し方**

本ガイドラインの命名規則は、Figmaのアセットパネルでの検索性を最大化するように設計されています。

**検索のヒント:**

* **特定のコンポーネントを探す:**  
  * Button と検索すれば、全てのボタンコンポーネントが見つかります。  
* **ライブラリで絞り込む:**  
  * Icon/Lucide と検索すれば、Lucideのアイコンが一覧表示されます。

このルールに従うことで、誰でも迷うことなく、必要なコンポーネントを迅速に見つけ出すことができます。