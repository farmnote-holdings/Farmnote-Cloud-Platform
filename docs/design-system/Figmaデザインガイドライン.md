# **Farmnote Cloud Figmaデザインガイドライン Ver.1.02**

**最終更新日:** 2025年07月20日

## **1. はじめに**

### **1.1. このガイドラインの目的**

このドキュメントは、Farmnote Cloud PlatformのUI/UX設計に関わるすべてのメンバー（デザイナー、エンジニア、プロダクトマネージャー等）のための公式なFigma利用ガイドラインです。

本ガイドラインの目的は、製品戦略とデザインシステムの原則に基づき、Figma上でのデザインプロセスを標準化することです。これにより、**「インテリジェント」「ストレスフリー」「統合された」**ユーザー体験を、チーム一丸となって効率的かつ一貫性をもって実現します。

### **1.2. ガイドラインが目指す状態**

*   **予測可能性:** 誰がファイルを開いても、目的のデザインアセットをすぐに見つけられる。
*   **一貫性:** すべてのデザインがデザインシステムのルールに準拠し、プラットフォーム全体で統一された体験を提供する。
*   **効率性:** ルール化とコンポーネント化により、無駄な作業をなくし、設計と開発のスピードを向上させる。
*   **協調性:** デザイナーとエンジニアが共通の言語と構造でスムーズに連携できる。

## **2. Figma設計の基本原則**

具体的な手法の前に、Figmaでデザインを構築する上で常に守るべき3つの基本原則を定めます。

### **2.1. デザインシステムと完全に連携する**

Figma上のデザインは、必ず公式の「Farmnote Cloud Platform デザインシステム」と連携している必要があります。

*   **コンポーネントはインスタンスで利用する:**
    デザインシステムで定義されたコンポーネントは、必ず**インスタンス（Instance）として使用**します。コンポーネントをデタッチしてローカルで編集することは、一貫性を破壊し、メンテナンス性を著しく低下させるため**原則として禁止**します。

*   **スタイルを適用する:**
    カラー、タイポグラフィ、エフェクト（影）、グリッドは、必ずデザインシステムで定義された**スタイルを適用**します。ローカルで直接カラーコードやフォントサイズを指定することは避けてください。これにより、デザインシステム側の変更が全てのデザインに即座に反映されます。

### **2.2. Auto Layoutを全面的に採用する**

*   **柔軟なコンポーネント設計:** マージン、パディング、要素間のスペース管理には、**Auto Layoutを全面的に採用**します。これにより、デザインシステムで定義されたスペーシングスケールを遵守し、要素の追加・削除に柔軟に対応できます。例えば、ボタンのラベルが長くなっても幅が自動で調整されるように設定することで、「テキスト長S/M/L」のような不要なバリアントを作成する必要がなくなります。

*   **意図が伝わるレイヤー名:** Auto Layoutを適用したフレームには、そのレイアウト意図がひと目で分かる名前を付けます。これらはFigma上の管理名のため、 **半角スペースの使用を許可します。** （例: 📏 Padding Wrapper, text + icon）

*   **レスポンシブ挙動の定義:** Auto LayoutのResizing設定は、以下の指針で使い分け、親フレームのサイズが変更された際の挙動を明確に定義します。
    *   **Fill Container:** 親フレームのサイズ変更に追従させたい場合に原則として使用します。
    *   **Hug Contents:** コンテンツ自身のサイズ（テキスト長など）に合わせてフレームサイズを可変させたい場合（例: ボタン、タグ）に使用します。
    *   **Fixed:** サイズを固定したい場合（例: アバター、特定のサイズのアイコン）に使用します。

### **2.3. バリアントのレイヤー構造を統一する**

*   **上書き保持のための構造統一:** 同一コンポーネントセット内の全バリアントで、**レイヤー構造と名前付けを完全に一致**させます。これは、バリアントの状態を切り替えた際に、テキストやインスタンスの上書き内容を保持するために不可欠です。

*   **一括編集の実現:** レイヤー構造を統一することで、複数のバリアントを選択して一括で編集したり、管理が大幅に容易になります。

## **3. ファイルとページの構成**

Figmaファイルを開いたときに、誰もが迷わず全体像を理解できるように、ファイル・ページの構成ルールを定めます。

### **3.1. 推奨ページ構成**

Farmnote Cloud Platformは複数の専門アプリケーションで構成されるため、Figmaファイル内のページをアプリケーション単位で明確に分離し、ファイル全体の可読性とパフォーマンスを維持します。

| アイコン | ページ名 | 説明 |
| :--- | :--- | :--- |
| ✅ | Cover | ファイルの表紙。プロジェクト概要、ステータス、更新履歴を記載します。 |
| 🧩 | Design System | カラー、タイポグラフィ、アイコン等、プラットフォーム共通のコンポーネントを定義します。 |
| --- | --- | --- |
| 🐄 | Herd Management | Herd Managementアプリの画面デザイン。画面数が多い場合は機能で分割も可。 |
| 🌈 | Color | Colorアプリの画面デザイン。 |
| 📊 | Compass | Compassアプリの画面デザイン。 |
| 🧬 | Gene | Geneアプリの画面デザイン。 |
| 🤖 | Assistant | Assistantアプリの画面デザイン。 |
| 🛒 | Inventory | Inventoryアプリの画面デザイン。 |
| 👤 | Account Portal | Account Portalアプリの画面デザイン。 |
| --- | --- | --- |
| 🌊 | Prototypes | アプリを横断するプロトタイプや、複雑なユーザーフロー図を配置します。 |
| ✍️ | Sandbox - [担当者名] | 各担当者が自由に試行錯誤するための、個人作業用のページです。 |
| 📌 | Archive | 古くなったデザインや不採用案を保管するページです。 |

### **3.2. 推奨レイアウト構造（App Shellモデル）**

アプリケーションの基本的なレイアウトとして、以下の「App Shell」モデルを推奨します。

🖥️ Herd Management / Cow List / _Default (画面フレーム)
│
└─ 📄 App (Auto Layout: 横)
   │ // アプリケーション全体のラッパー
   │
   ├─ 🧩 NavBar (Component)
   │  │ // 左側固定のメインナビゲーション
   │  │
   │  └─ 📄 Content (Auto Layout: 縦)
   │     │
   │     ├─ 🧩 AppSwitcher (Component)
   │     └─ 📄 NavGroup (Auto Layout: 縦)
   │        └─ ... (NavList)
   │
   └─ 📄 Main (Auto Layout: 縦)
      │ // メインコンテンツ領域
      │
      ├─ 🧩 TopBar (Component)
      │  │ // ページタイトルやアクションを配置
      │
      └─ 📄 Container (Auto Layout: 横) // メインコンテンツと右サイドバーのラッパー
         │ // メインコンテンツの最大幅を制御
         │
         ├─ ... (テーブルやカードなどの主要コンテンツ)
         │
         └─ 🧩 SideBar (Component)
            │ // 右からスライドインする補助的なパネル
            │ // (例: フィルタ、並び替え、詳細情報)
            │ // デフォルトは非表示

## **4. 命名規則**

命名にはスラッシュ / を用いて階層構造を表現し、Figmaのアセットパネルでの整理と検索を容易にします。

### **4.1. 画面フレーム (トップレベルフレーム)**

PCとタブレットの表示は基本的に共通とし、管理コストを削減するため、主要なデザインターゲットを**デスクトップ**と**スマートフォン**の2つに絞ります。

*   **フォーマット:** [デバイスアイコン] [アプリ名] / [ページ名] / [状態・バリエーション]
*   **デバイスアイコン:**
    *   🖥️ : デスクトップ (タブレット表示も兼ねる)
    *   📱 : スマートフォン
*   **アプリ名:** 製品戦略で定義された正式名称を使用します。（例: Herd Management, Compass）
*   **ページ名:** 画面の内容が具体的にわかる名前を付けます。（例: Cow List, KPI Dashboard）
*   **状態・バリエーション (接頭辞 _ を使用):** 画面の特定の状態を示します。
    *   _Default: 基本状態
    *   _Empty: データが空の状態
    *   _Loading: 読み込み中
    *   _SideOverviewOpen: サイドオーバービュー表示時
    *   **例外的なタブレット表示:** もしタブレットで特有のレイアウトが必要な場合は、_Tablet のようにバリエーションとして表現します。
*   **命名例:**
    *   🖥️ Herd Management / Cow List / _Default
    *   🖥️ Compass / KPI Dashboard / _ProfitImpact
    *   📱 Assistant / Chat / _HandsFreeInput
    *   🖥️ Herd Management / Farm Board / _Tablet (例外的なケース)

### **4.2. コンポーネントの整理とバリアント**

コンポーネントの管理は、**フレームによる分類**と**バリアントによる状態管理**を組み合わせて行います。これにより、ライブラリの整理と、効率的なデザイン作業を両立します。

*   **整理方法 (フレーム構造):**
    1.  Design Systemページ内に、コンポーネントを以下の分類に基づいたフレームに分けて整理します。
        *   **Atoms:** UIを構成する最小単位。（例: Button, Input, Label）
        *   **Molecules:** 複数のAtomsで構成される小さな機能単位。（例: InputField, SearchForm）
        *   **Organisms:** 複数のMoleculesやAtomsで構成される、より自立したUIパーツ。（例: Header, Card）
        *   **Platform Specifics:** 特定のアプリに強く依存し、再利用性が低い複雑なコンポーネント。（例: SideOverviewPanel）
    2.  各フレーム内に、対応するマスターコンポーネント（コンポーネントセット）を配置します。
*   **バリアントによる状態管理:** 複数の状態や種類を持つコンポーネントは、個別のコンポーネントを複数作成するのではなく、Figmaの**コンポーネントプロパティ（バリアント）機能**を活用して、単一のコンポーネントセットにまとめます。
    *   **コンポーネント名:** コンポーネントセット自体の名前は、ButtonやCardのように、その役割を示すシンプルなものにします。
    *   **プロパティ定義:** Type（種類）、Size（サイズ）、State（状態）といった明確なプロパティを定義します。プロパティ名と値は、全コンポーネントで統一します。
    *   **Inputコンポーネントの設計:**
        *   **Input (Atom):** <input>や<textarea>タグに相当する、純粋な入力要素。
            *   プロパティ: Type: Text/Password/Textarea, Size: Lg/Md/Sm, State: Default/Hover/Focus/Filled/Error/Disabled
        *   **InputField (Molecule):** ラベル、説明文、エラー文を含む、フォームの1項目全体。
            *   プロパティ: WithLabel: True/False, WithDescription: True/False, WithError: True/False, Required: True/False
    *   **アイコン関連プロパティ:** アイコンを含むコンポーネント（例: Button）には、以下のプロパティを追加します。
        *   ShowIcon (ブーリアン): アイコンの表示/非表示を切り替えます。
        *   IconPosition (バリアント): Left, Right のいずれかを指定します。
        *   Icon (インスタンススワップ): 表示するアイコンコンポーネント（例: Icon/Lucide/Home）を差し替えます。

### **4.3. 命名の原則 (Naming Principles)**

*   **文脈に応じた命名 (Context-Based Naming):** コンポーネントを汎用的に作るか、専用に作るかの判断は、再利用性の鍵となります。
    *   **専用コンポーネントとして作成するケース:** NavItem, PopupItem, ActivityBtn, AnimalTabBarのように、使われる文脈（場所）と、それに最適化された具体的な見た目（サイズ、余白、スタイル）が密接に結びついている場合。これらは、その文脈に特化した名前（[文脈] + [種別]）で作成します。
    *   **汎用コンポーネントとして作成するケース:** ButtonやCardのように、アプリケーションの様々な場所で、同じ見た目・同じルールで再利用されることが明確な場合。これらは、その構造や役割を示す汎用的な名前で作成します。
*   **パスカルケースの使用 (Use of PascalCase):** **コンポーネント名、プロパティ名、プロパティの値**は、スペースを含まず、単語の先頭を大文字でつなげる**パスカルケース**（例: NavItem, SideOverviewPanel, ShowIcon, IconPosition）で記述します。これはReactなどのフレームワークにおける標準的な命名規則であり、開発との連携をスムーズにします。
*   **コードとの連携 (Alignment with Code):** Figma上の名称は、可能な限りコードベースやデザイントークンで使われている用語と一致させます。
*   **明確さを優先 (Clarity over Brevity):** チームで共通認識が取れないような、難解な省略形は避けます。基本的には省略せずに明確な名前を使用することを推奨しますが、一般的に広く使われている略称については使用を許可します。
*   **アイコンの命名規則 (Icon Naming Convention):** アイコンは数が多く特殊なため、他のコンポーネントとは別のシンプルな命名規則を適用し、パフォーマンスへの影響を考慮して**バリアントは使用しません。**
    *   **フォーマット:** Icon/[ライブラリ]/[アイコン名]
    *   **ライブラリ:** Lucide を基本とします。カスタムアイコンの場合は `Custom` とします。
    *   **アイコン名:** Lucide のアイコン名（例: Home, User）をそのまま使用します。
*   **役割に応じたインスタンス名の付与 (Assigning Role-Based Instance Names):** 同じコンポーネントやフレームでも、文脈によって役割が異なる場合があります。その場合、レイヤーパネル上での可読性を高めるため、インスタンス名に役割を示す接尾辞を追加します。これらはFigma上の管理名でありコードには影響しないため、**半角スペースの使用を許可します。**
    *   **フォーマット:** [元の名前] - [役割]
    *   **例:** NavList - Menu, NavList - CowList
*   **内部コンポーネントの区別 (Distinguishing Internal Components):** ライブラリとして公開せず、内部でのみ使用するコンポーネントには、名前の先頭にアンダースコア _ を付けます。Figmaの仕様上、_ や . で始まるコンポーネントはライブラリから除外されます。

### **4.4. デバイス別コンポーネントの設計 (PC / Mobile)**

PCとモバイルでスタイル（文字サイズや高さなど）が異なるコンポーネントを設計する際、単一のコンポーネントに`Device=PC/Mobile`のようなバリアントを追加することは、組み合わせの爆発を引き起こしコンポーネントを過度に複雑化させるため、**原則として禁止**します。

代わりに、スタイル（デザイントークン）とコンポーネントを分離するアプローチを採用します。

1.  **スタイルをデバイス別に定義する:**
    まず、テキストスタイルやスペーシングといった基本的なスタイル（デザイントークン）を、PC用とモバイル用でそれぞれ定義します。

    例: `--font-nav-item/PC`, `--font-nav-item/Mobile`

2.  **デバイス別のコンポーネントを作成する:**
    次に、それらのスタイルを参照する形で、デバイスごとのコンポーネントを個別に作成します。コンポーネント名には、デバイスを示す接尾辞をスラッシュで区切って付与します。

    **命名フォーマット:** `[コンポーネント名]/[デバイス]`

    **命名例:**

    *   `NavItem/PC`
    *   `NavItem/Mobile`

3.  **プロパティ（API）を完全に一致させる:**
    最も重要なのは、デバイス別に作成したコンポーネント（例: `NavItem/PC`と`NavItem/Mobile`）が、全く同じプロパティ（バリアント、ブーリアン等）を持つように設計することです。これにより、見た目はデバイスに応じて最適化されつつ、コンポーネントの「使い方」は一貫性が保たれ、デザイナーは迷うことなく利用できます。



## **5. Component Properties の基本**

コンポーネントの再利用性と管理性を最大限に高めるため、Figmaのコンポーネントプロパティを適切に使い分けることが不可欠です。プロパティには主に4つの種類があり、それぞれに最適な用途があります。

### **5.1. Variant (バリアント)**

*   **役割:** コンポーネントの**状態（State）、種類（Type）、サイズ（Size）**など、複数の視覚的なバリエーションを管理します。コンポーネントが根本的に異なる見た目を複数持つ場合に最適です。
*   **使い方の例:**
    *   `Button`コンポーネントの`Type`プロパティ（`Primary`, `Secondary`, `Danger`）
    *   `Input`フィールドの`State`プロパティ（`Default`, `Hover`, `Focus`, `Error`）
    *   `Card`コンポーネントの`Size`プロパティ（`Sm`, `Md`, `Lg`）
*   **ポイント:** バリアントを使いすぎるとコンポーネントが複雑化しすぎることがあります。単なる表示/非表示やテキストの変更には、他のプロパティが適しています。

### **5.2. Boolean (ブーリアン)**

*   **役割:** コンポーネント内部の**特定の単一要素**（例: アイコン、説明文）の表示／非表示を切り替える場合に最適です。
*   **使い方の例:**
    *   `Button`コンポーネントの`ShowIcon`プロパティ（`True` / `False`）
    *   `InputField`コンポーネントの`WithDescription`プロパティ（`True` / `False`）
    *   `ListItem`コンポーネントの`WithBadge`プロパティ（`True` / `False`）
*   **ポイント:** バリアントで`ShowIcon: True/False`のような組み合わせを作るのではなく、ブーリアンプロパティを使うことで、コンポーネントの組み合わせ数を爆発的に増やすことなく、柔軟な制御が可能になります。ただし、複数の要素や複雑なレイアウトの表示/非表示を制御しようとすると、プロパティの組み合わせが複雑化し、コンポーネントの見通しが悪くなります。そのような**コンテンツの差し替えや、複数の要素の出し分けには、後述するSlotパターンが遥かに優れた解決策となります。**

### **5.3. Text (テキスト)**

*   **役割:** コンポーネント内の**テキスト内容を直接編集可能**にします。これにより、デザイナーはプロパティパネルから直感的にテキストを修正できます。
*   **使い方の例:**
    *   `Button`コンポーネントのラベルテキスト
    *   `Card`コンポーネントのタイトルと説明文
    *   `ListItem`コンポーネントの項目名
*   **ポイント:** マスターコンポーネントからこのプロパティをリンクしておくことで、インスタンスを選択した際に、サイドバーの目立つ位置にテキスト編集フィールドが表示され、作業効率が向上します。

### **5.4. Instance Swap (インスタンススワップ)**

*   **役割:** コンポーネント内のネストされた**インスタンスを、別のコンポーネントに差し替え**ます。特にアイコンの切り替えに非常に強力です。
*   **使い方の例:**
    *   `Button`コンポーネントのアイコンを、`Icon/Lucide/Home`から`Icon/Lucide/Settings`に差し替える。
    *   `ListItem`の先頭にあるアバター画像を、別のユーザーのアバターコンポーネントに差し替える。
    *   `Card`のヘッダー部分にあるアイコンを差し替える。
*   **ポイント:** 差し替えたいコンポーネント（例: アイコン）は、あらかじめライブラリに登録しておく必要があります。プロパティパネルで、差し替え可能なコンポーネントライブラリを指定することもできます。

### **5.5. 応用パターン: プロパティ活用の具体例**

`AppSwitcher`のように、構造は同じで中身のアイコンやテキストだけが変わるコンポーネントは、種類ごとのバリアント（例: `Type=Compass`, `Type=Gene`）を作るべきではありません。代わりに、コンポーネントプロパティを以下のように活用します。

*   **部品（コンポーネント）は状態のみを管理する:**
    `AppSwitcher`コンポーネント自体は、`Default`, `Hover`, `Active`といった**状態（State）**のバリアントのみを持ちます。
*   **内容（コンテンツ）はプロパティで差し替える:**
    表示するアイコンは**インスタンススワップ**、アプリケーション名は**テキストプロパティ**として定義します。

この設計により、将来新しいアプリケーションが追加されても、デザイナーはライブラリのコンポーネント自体を修正することなく、インスタンスのプロパティを変更するだけで柔軟に対応できます。これにより、メンテナンス性と拡張性が劇的に向上します。

## **6. レイアウト設計パターン**

メンテナンス性と拡張性を高めるため、フレームの構造に以下の設計パターンを設けます。

### **6.1. Container パターンによるコンテンツ幅の制御**

ヘッダーやサイドバーは画面幅いっぱいに広げつつ、**メインコンテンツ領域の可読性を担保するため**にContainerフレームを配置します。

*   **役割:** **メインコンテンツ領域に最大幅（例: 1280px）を設定し、コンテンツが横に広がりすぎるのを防ぎます。**
*   **配置場所:** ページ全体ではなく、**メインコンテンツをラップする形**で配置します。

### **6.2. Wrapper / Content パターン**

ヘッダーやカードなど、**少し複雑なコンポーネント**を設計する際は、**外側（Wrapper）と内側（Content）でフレームを分離する**ことで、柔軟性とメンテナンス性を高めます。

*   **Wrapper (ラッパー):** コンポーネントの一番外側のフレーム。背景色、枠線、角丸、影などの**装飾**を設定します。
*   **Content (コンテンツ):** Wrapperの直下に配置し、フレーム名を **Content** とします。このフレームは、コンテンツそのものと、内側の余白（**Padding**）を管理します。
*   **メリット:** 「装飾」と「中身・余白」の役割を分離でき、堅牢で再利用性の高いコンポーネント設計が可能になります。
*   **使い分け:** ヘッダー、カード、モーダルなど、内部に複数の要素を持つ複雑なコンポーネントで推奨します。ボタンやタグなど、単一のフレームで十分に管理できるシンプルなコンポーネントでは不要です。

### **6.3. Container と Content の役割分担**

ContainerとContentは似ていますが、明確な役割の違いがあります。これらを区別することで、レイアウトの意図がより明確になります。

*   **Container の役割: ページの「メインコンテンツ幅」を制御する**
    *   これは、 **ページ全体のレイアウト** に関わる、大きな枠組みです。
    *   主な目的は、PCなどの横長の画面で、本文やリストなどの主要なコンテンツが横に広がりすぎて見づらくなるのを防ぐことです。
*   **Content の役割: 「コンポーネント内部」の余白と要素を管理する**
    *   これは、HeaderやCardといった、 **個々のコンポーネントの内部構造** に関わる、小さな枠組みです。
    *   主な目的は、そのコンポーネントの中でのPadding（内側の余白）や、要素（ロゴ、テキスト、アイコンなど）の配置を管理することです。

**Containerは「ページの器」、Contentは「部品の中身」**と役割を明確に分けることで、デザイナーもエンジニアも、そのフレームが何のためのものかを直感的に理解できるようになります。

### **6.3. コンポーネント内部構造の具体例: AnimalStatusBar**

コンポーネントの内部フレームには、「どこにあるか」(Left/Right)ではなく、「何であるか」で命名します。

🧩 AnimalStatusBar (Component)
│
└─ 📄 Content (Auto Layout: 横, Space between)
   │
   ├─ 📄 Identification (Auto Layout: 横)
   │  │ // 個体識別情報エリア
   │  ├─ 🧩 CowAvatar
   │  └─ 📄 Info
   │     │ // 親が`Identification`なのでシンプルに`Info`とする
   │     ├─ 📄 EarTagInfo
   │     │  └─ 📄 Number // 親が`EarTagInfo`なので`EarTagNumber`とせずシンプルに
   │     ├─ 📄 NationalID
   │     └─ 📄 Breed
   │
   └─ 📄 Status (Auto Layout: 横)
      │ // 個体の状態エリア
      └─ 🧩 ReproductiveStatus (Tag Component)

## **7. 可変コンテンツの設計**

Popover、Menu、モーダルのように、コンポーネントの一部が動的に変化したり、外部からコンテンツを注入されたりするケースに対応するための、高度な設計パターンを定めます。

### **7.1. Slot パターン (Instance Swapの応用)**

この手法は、Web Componentsの`<slot>`タグやReactの`children` propに相当する考え方であり、柔軟性と拡張性に優れたコンポーネントを設計するための**業界標準のベストプラクティス**です。コンポーネントの特定領域を「スロット（Slot）」として定義し、そこに別のコンポーネントを自由に差し込めるようにする、極めて再利用性の高い設計手法です。

**実現方法:**

1.  **スロット用プレースホルダーの作成:**
    まず、高さと幅を**`0.01px`**に設定した、`_SlotPlaceholder`のような名前の空のコンポーネントを作成します。これは「空のスロット」の役割を果たし、Auto Layout内で非表示のように振る舞います。

2.  **シェルコンポーネントの定義 (Popoverの例):**
    *   `Popover`のような「シェル（殻）」となるコンポーネントを、縦方向のAuto Layoutで作成します。
    *   その内部に、先ほど作成した`_SlotPlaceholder`のインスタンスを**複数個（例: 10個）**配置します。これにより、最大10個のコンポーネントを入れ子にして、柔軟なUIを構築できます。
    *   配置した各スロットのレイヤー名を`Slot 1`, `Slot 2`... のように変更します。

3.  **Instance Swapプロパティの適用:**
    `Slot 1`から`Slot 10`までの各インスタンスに対して、`Instance Swap`プロパティを割り当てます。

**使い方の例: Popoverコンポーネント**

*   デザイナーは`Popover`コンポーネントのプロパティパネルから、`Slot 1`に`MenuItem`を、`Slot 2`に`Divider`を、というように、必要なコンテンツを順番に注入（スワップ）していきます。
*   ヘッダーが不要な場合や、10個すべてのスロットを使わない場合は、対象のスロットに「空のスロット」（`_SlotPlaceholder`）をセットしたままにします。`0.01px`のコンポーネントは視覚的に見えないため、実質的にそのスロットは非表示になります。

**重要なポイント: スロットに注入するコンポーネントの設計**

*   このパターンを正しく機能させるためには、スロットに注入する側のすべてのコンポーネント（例: `MenuItem`, `Divider`, `ListHeader`など）で、**高さのResizing設定を`Hug Contents`にしておく**必要があります。
*   これにより、各コンポーネントが自身のコンテンツに合った高さを保ち、それらを内包する`Popover`全体の高さも、中身に応じて自動的に調整されるようになります。

### **7.2. Slotパターン vs Booleanプロパティ**

コンポーネント内要素の表示を切り替える際、Booleanプロパティを使うか、Slotパターンを使うかは重要な設計判断です。私たちのガイドラインでは、以下の思想に基づき、**原則としてSlotパターンの採用を強く推奨します。**

| 特徴 | Booleanプロパティ (`ShowIcon`) | Slotパターン (`Slot 1`, `Slot 2`...) |
| :--- | :--- | :--- |
| **思想** | コンポーネント自身が「何を表示できるか」を**すべて知っている** | 親コンポーネントは「どこに表示できるか」だけを提供し、**中身は知らない** |
| **長所** | ・実装がシンプルで直感的<br>・単一要素のON/OFFに最適 | ・**圧倒的な柔軟性**: どんなコンポーネントでも注入できる<br>・**高い拡張性**: 将来新しい要素を追加する際、親の修正が不要<br>・**関心の分離**: 親はレイアウト、子はコンテンツに責任を持つ |
| **短所** | ・**柔軟性に欠ける**: 新しい要素（例: バッジ）を追加したい場合、親コンポーネント自体を修正する必要がある<br>・**拡張性が低い**: 要素が増えるたびにプロパティが肥大化し、管理が複雑になる | ・プレースホルダーの準備など、初期設定がやや複雑 |
| **最適な用途** | ボタンのアイコンのように、**コンポーネントに不可分な特定要素**の表示/非表示 | PopoverやModalのように、**中身が文脈によって大きく変わる**コンポーネント |

**結論:**

Booleanプロパティは、そのコンポーネントの**本質的な構成要素**（例: ボタンにおけるアイコンの有無）の切り替えに限定して使用します。

一方、コンポーネントの一部として**未知のコンテンツを受け入れる可能性があるすべてのケース**（例: カードのボディ、モーダルのフッター、リストのアイテム）においては、Slotパターンを採用してください。このアプローチにより、一貫性を保ちながら、個々の画面要件に柔軟に対応できる、真に再利用可能なコンポーネント資産を構築できます。

## **8. 開発連携 (Collaboration with Development)**

### **8.1. FigmaからReactへの連携**

本ガイドラインのコンポーネント管理方法は、Reactなどのコンポーネントベースのフレームワークとの連携を円滑にするために設計されています。

#### **命名規則と実装のマッピング**

1.  **コンポーネントの分類 → ファイルパス**
    *   Figma: Atomsフレーム内の`Button`コンポーネント
    *   React: `src/components/atoms/Button.tsx`
2.  **コンポーネントプロパティ → Props**
    *   Figma: `Type=Primary`, `Size=Md`
    *   React: `<Button type="primary" size="md">`
3.  **InputFieldとInputの関係**
    *   InputFieldは、Inputを子要素として受け取るラッパーとして実装します。
    *   `<InputField label="名前"><Input type="text" /></InputField>`
4.  **アイコンの場合**
    *   Figma: `Icon/Lucide/Home`
    *   React: `<Icon library="lucide" name="home" />`

| Figmaでのコンポーネント | Reactでの実装（JSX） |
| :---- | :---- |
| Button (Type=Primary, Size=Md, ShowIcon=True, Icon=Icon/Lucide/Save) | `<Button type="primary" size="md" icon={<Icon name="save" />}>保存</Button>` |
| InputField と Input | `<InputField label="名前"><Input type="text" /></InputField>` |

#### **このルールのメリット**

*   **明確なProps設計:** デザイナーがバリアントを作成する時点で、開発者は必要なPropsを直感的に理解できます。
*   **コンポーネントの再利用性向上:** `PrimaryButton`のような個別のコンポーネントを乱立させず、効率的な設計を促進します。
*   **共通言語の確立:** デザイナーと開発者が完全に一貫した言葉でコミュニケーションできます。

## **9. 付録 (Appendix)**

### **9.1. 命名許容リスト (略称)**

| 正式名称 | 略称 | 備考 |
| :--- | :--- | :--- |
| Button | Btn | |
| Image | Img | |
| Navigation | Nav | |
| Message | Msg | |
| Activity| Act | |
| Dialog | Dlg | |
| Thumbnail | Thumb | |
| Background | BG | |
| Number | Num | |
| Checkbox | Chk | |

### **9.2. プロパティ チートシート**

コンポーネントのプロパティで頻繁に使用する命名の定義一覧です。

| プロパティの種類 | プロパティ名 | 説明 |
| :--- | :--- | :--- |
| **種類 (Type)** | Primary, Secondary, Tertiary, Danger | コンポーネントの種類や優先度 |
| **サイズ (Size)** | Lg, Md, Sm | コンポーネントの大きさ |
| **状態 (State)** | Default, Hover, Active, Focus, Loading, Disabled | インタラクティブな状態 |
| **アイコン (Icon)** | ShowIcon, IconPosition, Icon | アイコンの表示、位置、種類 |

### **9.3. コンポーネントの探し方**

Figmaのアセットパネルで、`Button`や`Icon/Lucide`のように検索することで、必要なコンポーネントを迅速に見つけ出すことができます。